/**
 * LUMI Content Script
 * Handles page interaction, selection modes, Bubble UI, and screenshot capture
 */

(function() {
  'use strict';

  // Prevent double injection
  if (window.LUMI_INJECTED) {
    console.log('[LUMI Content] Already injected');
    return;
  }
  window.LUMI_INJECTED = true;

  console.log('[LUMI Content] Initializing v2.0 (with CSS apply)...');

  // State
  let selectionMode = 'element'; // 'element' or 'screenshot'
  let isElementModeActive = true; // Element mode is default
  let isScreenshotModeActive = false;
  let isSelecting = false;
  let selectionStart = null;
  let selectionOverlay = null;
  let bubbleContainer = null;
  let selectedElements = []; // Array of {element, selector, tagName, bbox}
  let screenshotData = null; // {dataUrl, bbox}
  let hoveredElement = null;
  let hoverOverlay = null;
  let topBanner = null;

  // Initialize
  init();

  function init() {
    // Load settings
    chrome.storage.local.get(['selectionMode'], (result) => {
      if (result.selectionMode) {
        selectionMode = result.selectionMode;
      }
      createBubble();
      attachEventListeners();
    });
  }

  // Create Bubble UI with Shadow DOM
  function createBubble() {
    if (bubbleContainer) {
      return; // Already exists
    }

    // Create container
    bubbleContainer = document.createElement('div');
    bubbleContainer.id = 'lumi-bubble-container';
    bubbleContainer.style.cssText = `
      position: fixed;
      z-index: 2147483647;
      display: none;
    `;

    // Attach shadow DOM
    const shadow = bubbleContainer.attachShadow({ mode: 'open' });

    // Create modern minimalist Bubble HTML
    shadow.innerHTML = `
      <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }

        :host {
          --bg-primary: rgba(15, 23, 42, 0.95);
          --bg-secondary: rgba(30, 41, 59, 0.9);
          --accent-blue: #3b82f6;
          --accent-green: #10b981;
          --text-primary: rgba(248, 250, 252, 0.95);
          --text-secondary: rgba(226, 232, 240, 0.6);
          --border: rgba(148, 163, 184, 0.2);
        }

        .bubble {
          width: 420px;
          background: var(--bg-primary);
          backdrop-filter: blur(24px) saturate(180%);
          border-radius: 12px;
          border: 1px solid var(--border);
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
          color: var(--text-primary);
          animation: slideInUp 0.3s cubic-bezier(0.16, 1, 0.3, 1);
          overflow: hidden;
        }

        @keyframes slideInUp {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        /* Top Bar */
        .top-bar {
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 12px 16px;
          border-bottom: 1px solid var(--border);
          background: rgba(15, 23, 42, 0.6);
        }

        .left-section {
          display: flex;
          align-items: center;
          gap: 12px;
        }

        .logo {
          font-size: 14px;
          font-weight: 600;
          letter-spacing: 0.5px;
          color: var(--text-primary);
        }

        .engine-selector {
          position: relative;
          display: flex;
          align-items: center;
          gap: 6px;
          padding: 4px 10px;
          background: rgba(255, 255, 255, 0.05);
          border: 1px solid var(--border);
          border-radius: 6px;
          cursor: pointer;
          font-size: 12px;
          transition: all 0.15s;
        }

        .engine-selector:hover {
          background: rgba(255, 255, 255, 0.08);
          border-color: rgba(148, 163, 184, 0.3);
        }

        .status-indicator {
          width: 6px;
          height: 6px;
          border-radius: 50%;
          background: var(--accent-green);
          animation: pulse 2s ease-in-out infinite;
        }

        .status-indicator.offline {
          background: #ef4444;
          animation: none;
        }

        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        }

        .engine-name {
          font-size: 12px;
          font-weight: 500;
        }

        .dropdown-arrow {
          font-size: 10px;
          opacity: 0.6;
        }

        .right-section {
          display: flex;
          align-items: center;
          gap: 4px;
        }

        .icon-btn {
          width: 28px;
          height: 28px;
          display: flex;
          align-items: center;
          justify-content: center;
          border: 1px solid transparent;
          background: transparent;
          border-radius: 6px;
          cursor: pointer;
          font-size: 14px;
          color: var(--text-secondary);
          transition: all 0.15s;
        }

        .icon-btn:hover {
          background: rgba(255, 255, 255, 0.08);
          color: var(--text-primary);
          border-color: var(--border);
        }

        .icon-btn.active {
          background: var(--accent-blue);
          color: white;
          border-color: var(--accent-blue);
        }

        .icon-btn svg {
          width: 16px;
          height: 16px;
        }

        /* Context Tags Section */
        .context-tags {
          display: flex;
          flex-wrap: wrap;
          gap: 6px;
          padding: 12px 16px;
          min-height: 20px;
          border-bottom: 1px solid var(--border);
          background: rgba(0, 0, 0, 0.2);
        }

        .context-tags:empty {
          display: none;
        }

        .context-tag {
          display: inline-flex;
          align-items: center;
          gap: 6px;
          padding: 4px 8px;
          background: rgba(59, 130, 246, 0.15);
          border: 1px solid rgba(59, 130, 246, 0.3);
          border-radius: 6px;
          font-size: 11px;
          font-weight: 500;
          color: #93c5fd;
          animation: scaleIn 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes scaleIn {
          from {
            opacity: 0;
            transform: scale(0.8);
          }
          to {
            opacity: 1;
            transform: scale(1);
          }
        }

        .context-tag.screenshot {
          background: rgba(16, 185, 129, 0.15);
          border-color: rgba(16, 185, 129, 0.3);
          color: #6ee7b7;
        }

        .tag-icon {
          font-size: 10px;
        }

        .tag-remove {
          width: 14px;
          height: 14px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 3px;
          cursor: pointer;
          font-size: 10px;
          opacity: 0.6;
          transition: all 0.15s;
        }

        .tag-remove:hover {
          opacity: 1;
          background: rgba(255, 255, 255, 0.1);
        }

        /* Input Container */
        .input-container {
          padding: 16px;
          position: relative;
        }

        .input-wrapper {
          position: relative;
          background: var(--bg-secondary);
          border: 1px solid var(--border);
          border-radius: 8px;
          transition: all 0.15s;
        }

        .input-wrapper:focus-within {
          border-color: var(--accent-blue);
          box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .input-field {
          width: 100%;
          min-height: 80px;
          max-height: 200px;
          padding: 12px 48px 12px 12px;
          background: transparent;
          border: none;
          color: var(--text-primary);
          font-size: 13px;
          font-family: inherit;
          line-height: 1.5;
          resize: none;
          outline: none;
        }

        .input-field::placeholder {
          color: var(--text-secondary);
        }

        .send-btn {
          position: absolute;
          right: 8px;
          bottom: 8px;
          width: 32px;
          height: 32px;
          display: flex;
          align-items: center;
          justify-content: center;
          background: var(--accent-blue);
          border: none;
          border-radius: 6px;
          cursor: pointer;
          transition: all 0.15s;
          color: white;
        }

        .send-btn:hover:not(:disabled) {
          background: #2563eb;
          transform: translateY(-1px);
          box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .send-btn:active:not(:disabled) {
          transform: translateY(0);
        }

        .send-btn:disabled {
          opacity: 0.4;
          cursor: not-allowed;
        }

        .send-btn svg {
          width: 16px;
          height: 16px;
        }

        /* Loading State */
        .loading-overlay {
          position: absolute;
          inset: 0;
          display: none;
          align-items: center;
          justify-content: center;
          background: rgba(15, 23, 42, 0.8);
          backdrop-filter: blur(4px);
          border-radius: 8px;
          animation: fadeIn 0.2s;
        }

        .loading-overlay.active {
          display: flex;
        }

        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        .loading-content {
          text-align: center;
        }

        .spinner {
          width: 32px;
          height: 32px;
          border: 3px solid rgba(59, 130, 246, 0.2);
          border-top-color: var(--accent-blue);
          border-radius: 50%;
          animation: spin 0.8s linear infinite;
          margin: 0 auto 8px;
        }

        @keyframes spin {
          to { transform: rotate(360deg); }
        }

        .loading-text {
          font-size: 12px;
          color: var(--text-secondary);
        }

        /* Status Message */
        .status-message {
          padding: 12px 16px;
          border-top: 1px solid var(--border);
          font-size: 12px;
          display: none;
          align-items: center;
          gap: 8px;
          animation: slideDown 0.2s;
        }

        @keyframes slideDown {
          from {
            opacity: 0;
            transform: translateY(-10px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        .status-message.active {
          display: flex;
        }

        .status-message.success {
          background: rgba(16, 185, 129, 0.1);
          color: var(--accent-green);
        }

        .status-message.error {
          background: rgba(239, 68, 68, 0.1);
          color: #ef4444;
        }

        .status-icon {
          font-size: 14px;
        }
      </style>

      <div class="bubble">
        <!-- Top Bar -->
        <div class="top-bar">
          <div class="left-section">
            <div class="logo">LUMI</div>
            <div class="engine-selector" id="engine-selector">
              <div class="status-indicator" id="status-indicator"></div>
              <span class="engine-name" id="engine-name">Codex</span>
              <span class="dropdown-arrow">▼</span>
            </div>
          </div>
          <div class="right-section">
            <button class="icon-btn active" id="element-mode-btn" title="Element Mode (Cmd+E)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <path d="M3 9h18M9 3v18"/>
              </svg>
            </button>
            <button class="icon-btn" id="screenshot-mode-btn" title="Screenshot Mode (Cmd+S)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <circle cx="12" cy="12" r="3"/>
              </svg>
            </button>
            <button class="icon-btn" id="close-btn" title="Close (Esc)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 6L6 18M6 6l12 12"/>
              </svg>
            </button>
          </div>
        </div>

        <!-- Context Tags -->
        <div class="context-tags" id="context-tags"></div>

        <!-- Input Container -->
        <div class="input-container">
          <div class="input-wrapper">
            <textarea 
              class="input-field" 
              id="intent-input" 
              placeholder="Type your instructions..."
            ></textarea>
            <button class="send-btn" id="send-btn" disabled>
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
              </svg>
            </button>
            <div class="loading-overlay" id="loading-overlay">
              <div class="loading-content">
                <div class="spinner"></div>
                <div class="loading-text" id="loading-text">Processing...</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Status Message -->
        <div class="status-message" id="status-message">
          <span class="status-icon" id="status-icon"></span>
          <span id="status-text"></span>
        </div>
      </div>
    `;

    document.body.appendChild(bubbleContainer);

    // Set up event listeners for bubble UI
    setupBubbleListeners(shadow);

    // Check server status
    checkServerStatus(shadow);
  }

  function setupBubbleListeners(shadow) {
    const closeBtn = shadow.getElementById('close-btn');
    const modeToggle = shadow.getElementById('mode-toggle');
    const reselectBtn = shadow.getElementById('reselect-btn');
    const submitBtn = shadow.getElementById('submit-btn');
    const intentInput = shadow.getElementById('intent-input');
    const engineBtns = shadow.querySelectorAll('.engine-btn');
    const bubble = shadow.getElementById('bubble');

    // Close bubble
    closeBtn.addEventListener('click', () => {
      hideBubble();
    });

    // Toggle selection mode
    modeToggle.addEventListener('click', () => {
      selectionMode = selectionMode === 'rectangle' ? 'element' : 'rectangle';
      chrome.storage.local.set({ selectionMode });
      updateModeIcon(shadow);
      showMessage(shadow, `Switched to ${selectionMode} mode`, 'success');
    });

    // Reselect
    reselectBtn.addEventListener('click', () => {
      resetSelection();
      hideBubble();
      startSelection();
    });

    // Submit
    submitBtn.addEventListener('click', () => {
      handleSubmit(shadow);
    });

    // Input handlers
    intentInput.addEventListener('input', () => {
      updateSubmitButton(shadow);
    });

    intentInput.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        if (!submitBtn.disabled) {
          handleSubmit(shadow);
        }
      }
    });

    // Engine selection
    engineBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const engine = btn.dataset.engine;
        chrome.storage.local.set({ engine });
        engineBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      });
    });

    // Drag to move
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };

    bubble.querySelector('.drag-handle').addEventListener('mousedown', (e) => {
      isDragging = true;
      const rect = bubbleContainer.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left;
      dragOffset.y = e.clientY - rect.top;
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      let x = e.clientX - dragOffset.x;
      let y = e.clientY - dragOffset.y;

      // Keep within viewport
      const maxX = window.innerWidth - bubbleContainer.offsetWidth;
      const maxY = window.innerHeight - bubbleContainer.offsetHeight;
      x = Math.max(0, Math.min(x, maxX));
      y = Math.max(0, Math.min(y, maxY));

      bubbleContainer.style.left = x + 'px';
      bubbleContainer.style.top = y + 'px';
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });
  }

  function updateModeIcon(shadow) {
    const modeIcon = shadow.getElementById('mode-icon');
    modeIcon.textContent = selectionMode === 'rectangle' ? '⬚' : '🎯';
  }

  function updateSubmitButton(shadow) {
    const submitBtn = shadow.getElementById('submit-btn');
    const intentInput = shadow.getElementById('intent-input');
    const hasSelection = selectedBBox || selectedElement;
    const hasIntent = intentInput.value.trim().length > 0;
    submitBtn.disabled = !(hasSelection && hasIntent);
  }

  async function checkServerStatus(shadow) {
    const statusDot = shadow.getElementById('status-dot');
    
    try {
      const response = await chrome.runtime.sendMessage({ type: 'CHECK_SERVER' });
      const healthy = typeof response === 'boolean' ? response : !!response?.healthy;
      if (healthy) {
        statusDot.classList.remove('offline');
      } else {
        statusDot.classList.add('offline');
      }
    } catch (error) {
      statusDot.classList.add('offline');
    }
  }

  function showMessage(shadow, text, type = 'success') {
    const container = shadow.getElementById('message-container');
    container.innerHTML = `<div class="message ${type}">${text}</div>`;
    
    setTimeout(() => {
      container.innerHTML = '';
    }, 5000);
  }

  function showBubble() {
    if (!bubbleContainer) {
      createBubble();
    }

    bubbleContainer.style.display = 'block';

    // Position near selection if available
    if (selectedBBox) {
      positionBubble(selectedBBox);
    } else {
      // Center on screen
      const x = (window.innerWidth - 400) / 2;
      const y = (window.innerHeight - 600) / 2;
      bubbleContainer.style.left = x + 'px';
      bubbleContainer.style.top = y + 'px';
    }

    // Update UI
    const shadow = bubbleContainer.shadowRoot;
    updateContextInfo(shadow);
    updateModeIcon(shadow);
    updateSubmitButton(shadow);

    // Focus input
    setTimeout(() => {
      shadow.getElementById('intent-input').focus();
    }, 100);
  }

  function hideBubble() {
    if (bubbleContainer) {
      bubbleContainer.style.display = 'none';
    }
  }

  function positionBubble(bbox) {
    const padding = 16;
    const bubbleWidth = 400;
    const bubbleHeight = 600;

    // Try to position to the right-bottom of selection
    let x = bbox.right + padding;
    let y = bbox.bottom - bubbleHeight;

    // Keep within viewport
    if (x + bubbleWidth > window.innerWidth) {
      x = bbox.left - bubbleWidth - padding;
    }
    if (x < 0) {
      x = padding;
    }

    if (y < 0) {
      y = bbox.bottom + padding;
    }
    if (y + bubbleHeight > window.innerHeight) {
      y = window.innerHeight - bubbleHeight - padding;
    }
    if (y < 0) {
      y = padding;
    }

    bubbleContainer.style.left = x + 'px';
    bubbleContainer.style.top = y + 'px';
  }

  function updateContextInfo(shadow) {
    const contextInfo = shadow.getElementById('context-info');
    const contextMode = shadow.getElementById('context-mode');
    const contextSelection = shadow.getElementById('context-selection');
    const contextUrl = shadow.getElementById('context-url');
    const thumbnail = shadow.getElementById('thumbnail');

    if (!selectedBBox && !selectedElement) {
      contextInfo.style.display = 'none';
      return;
    }

    contextInfo.style.display = 'block';
    contextMode.textContent = selectionMode === 'rectangle' ? 'Rectangle' : 'Element';
    contextUrl.textContent = window.location.hostname;

    if (selectionMode === 'rectangle' && selectedBBox) {
      const width = Math.round(selectedBBox.width);
      const height = Math.round(selectedBBox.height);
      contextSelection.textContent = `${width} × ${height}px`;
    } else if (selectedElement) {
      const tagName = selectedElement.tagName.toLowerCase();
      const className = selectedElement.className ? `.${selectedElement.className.split(' ')[0]}` : '';
      contextSelection.textContent = `${tagName}${className}`;
    }

    // Show thumbnail if we have a screenshot
    if (screenshotDataUrl) {
      thumbnail.innerHTML = `<img src="${screenshotDataUrl}" alt="Selection preview" />`;
    }
  }

  // Selection overlay
  function createSelectionOverlay() {
    if (selectionOverlay) {
      return selectionOverlay;
    }

    selectionOverlay = document.createElement('div');
    selectionOverlay.style.cssText = `
      position: fixed;
      border: 2px dashed #667eea;
      background: rgba(102, 126, 234, 0.1);
      pointer-events: none;
      z-index: 2147483646;
      display: none;
    `;
    document.body.appendChild(selectionOverlay);
    return selectionOverlay;
  }

  function updateSelectionOverlay(start, end) {
    if (!selectionOverlay) return;

    const left = Math.min(start.x, end.x);
    const top = Math.min(start.y, end.y);
    const width = Math.abs(end.x - start.x);
    const height = Math.abs(end.y - start.y);

    selectionOverlay.style.left = left + 'px';
    selectionOverlay.style.top = top + 'px';
    selectionOverlay.style.width = width + 'px';
    selectionOverlay.style.height = height + 'px';
    selectionOverlay.style.display = 'block';
  }

  function hideSelectionOverlay() {
    if (selectionOverlay) {
      selectionOverlay.style.display = 'none';
    }
  }

  function removeSelectionOverlay() {
    if (selectionOverlay) {
      selectionOverlay.remove();
      selectionOverlay = null;
    }
  }

  // Highlight element
  function highlightElement(element) {
    if (!element || element === bubbleContainer) return;

    // Remove previous highlights
    document.querySelectorAll('.lumi-element-highlight').forEach(el => {
      el.classList.remove('lumi-element-highlight');
    });

    element.classList.add('lumi-element-highlight');
  }

  function removeElementHighlight() {
    document.querySelectorAll('.lumi-element-highlight').forEach(el => {
      el.classList.remove('lumi-element-highlight');
    });
  }

  // Inject highlight styles
  function injectHighlightStyles() {
    if (document.getElementById('lumi-highlight-styles')) return;

    const style = document.createElement('style');
    style.id = 'lumi-highlight-styles';
    style.textContent = `
      .lumi-element-highlight {
        outline: 2px dashed #667eea !important;
        outline-offset: 2px !important;
        background: rgba(102, 126, 234, 0.1) !important;
      }
    `;
    document.head.appendChild(style);
  }

  // Event listeners for selection
  function attachEventListeners() {
    injectHighlightStyles();

    // Global keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Esc to close
      if (e.key === 'Escape') {
        if (bubbleContainer && bubbleContainer.style.display !== 'none') {
          hideBubble();
          e.preventDefault();
        }
        if (isSelecting) {
          cancelSelection();
          e.preventDefault();
        }
      }
    });

    // Start selection on page
    startSelection();
  }

  function startSelection() {
    isSelecting = true;
    document.body.style.cursor = selectionMode === 'rectangle' ? 'crosshair' : 'pointer';

    if (selectionMode === 'rectangle') {
      createSelectionOverlay();
      document.addEventListener('mousedown', handleRectangleMouseDown);
    } else {
      document.addEventListener('mousemove', handleElementMouseMove);
      document.addEventListener('click', handleElementClick, true);
    }
  }

  function cancelSelection() {
    isSelecting = false;
    document.body.style.cursor = 'default';
    hideSelectionOverlay();
    removeElementHighlight();

    document.removeEventListener('mousedown', handleRectangleMouseDown);
    document.removeEventListener('mousemove', handleRectangleMouseMove);
    document.removeEventListener('mouseup', handleRectangleMouseUp);
    document.removeEventListener('mousemove', handleElementMouseMove);
    document.removeEventListener('click', handleElementClick, true);
  }

  function resetSelection() {
    selectedBBox = null;
    selectedElement = null;
    screenshotDataUrl = null;
    hideSelectionOverlay();
    removeElementHighlight();
  }

  // Rectangle selection handlers
  function handleRectangleMouseDown(e) {
    if (e.target === bubbleContainer || bubbleContainer?.contains(e.target)) {
      return;
    }

    e.preventDefault();
    selectionStart = { x: e.clientX, y: e.clientY };
    document.addEventListener('mousemove', handleRectangleMouseMove);
    document.addEventListener('mouseup', handleRectangleMouseUp);
  }

  function handleRectangleMouseMove(e) {
    if (!selectionStart) return;

    const current = { x: e.clientX, y: e.clientY };
    updateSelectionOverlay(selectionStart, current);
  }

  async function handleRectangleMouseUp(e) {
    if (!selectionStart) return;

    const end = { x: e.clientX, y: e.clientY };
    const width = Math.abs(end.x - selectionStart.x);
    const height = Math.abs(end.y - selectionStart.y);

    // Minimum selection size
    if (width < 10 || height < 10) {
      cancelSelection();
      return;
    }

    selectedBBox = {
      left: Math.min(selectionStart.x, end.x),
      top: Math.min(selectionStart.y, end.y),
      right: Math.max(selectionStart.x, end.x),
      bottom: Math.max(selectionStart.y, end.y),
      width,
      height
    };

    cancelSelection();
    await captureAndCropScreenshot();
    showBubble();
  }

  // Element selection handlers
  function handleElementMouseMove(e) {
    if (e.target === bubbleContainer || bubbleContainer?.contains(e.target)) {
      return;
    }

    highlightElement(e.target);
  }

  async function handleElementClick(e) {
    if (e.target === bubbleContainer || bubbleContainer?.contains(e.target)) {
      return;
    }

    e.preventDefault();
    e.stopPropagation();

    selectedElement = e.target;
    const rect = selectedElement.getBoundingClientRect();
    selectedBBox = {
      left: rect.left,
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      width: rect.width,
      height: rect.height
    };

    cancelSelection();
    await captureAndCropScreenshot();
    showBubble();
  }

  // Screenshot capture and crop
  async function captureAndCropScreenshot() {
    try {
      const response = await chrome.runtime.sendMessage({ type: 'CAPTURE_SCREENSHOT' });
      
      if (response.error) {
        console.error('[LUMI Content] Screenshot error:', response.error);
        return;
      }

      // Crop the screenshot to selected area
      const croppedDataUrl = await cropScreenshot(response.dataUrl, selectedBBox);
      screenshotDataUrl = croppedDataUrl;

    } catch (error) {
      console.error('[LUMI Content] Failed to capture screenshot:', error);
    }
  }

  function cropScreenshot(dataUrl, bbox) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Account for device pixel ratio
        const dpr = window.devicePixelRatio || 1;
        
        const cropX = bbox.left * dpr;
        const cropY = bbox.top * dpr;
        const cropWidth = bbox.width * dpr;
        const cropHeight = bbox.height * dpr;

        canvas.width = cropWidth;
        canvas.height = cropHeight;

        ctx.drawImage(
          img,
          cropX, cropY, cropWidth, cropHeight,
          0, 0, cropWidth, cropHeight
        );

        resolve(canvas.toDataURL('image/png'));
      };
      img.src = dataUrl;
    });
  }

  // Handle submit
  async function handleSubmit(shadow) {
    const submitBtn = shadow.getElementById('submit-btn');
    const submitText = shadow.getElementById('submit-text');
    const submitSpinner = shadow.getElementById('submit-spinner');
    const intentInput = shadow.getElementById('intent-input');

    const intent = intentInput.value.trim();
    if (!intent || (!selectedBBox && !selectedElement)) {
      return;
    }

    // Disable submit and show spinner
    submitBtn.disabled = true;
    submitText.style.display = 'none';
    submitSpinner.style.display = 'block';

    try {
      // Get current engine
      const { engine } = await chrome.storage.local.get(['engine']);
      const selectedEngine = engine || 'codex';

      // Collect context
      const context = {
        engine: selectedEngine,
        intent,
        pageUrl: window.location.href,
        pageTitle: document.title,
        selectionMode,
        timestamp: new Date().toISOString()
      };

      if (selectionMode === 'rectangle') {
        context.bbox = selectedBBox;
        context.screenshot = screenshotDataUrl;
      } else if (selectedElement) {
        context.element = {
          tagName: selectedElement.tagName,
          className: selectedElement.className,
          id: selectedElement.id,
          outerHTML: selectedElement.outerHTML,
          selector: getElementSelector(selectedElement),
          computedStyle: getComputedStyleSummary(selectedElement)
        };
        context.bbox = selectedBBox;
        context.screenshot = screenshotDataUrl;
      }

      // Send to background -> server
      const response = await chrome.runtime.sendMessage({
        type: 'SEND_TO_SERVER',
        payload: {
          engine: selectedEngine,
          context
        }
      });

      if (response.error) {
        showMessage(shadow, `Error: ${response.error}`, 'error');
      } else if (response.success && response.output) {
        console.log('[LUMI Content] Response:', response);
        
        // Codex with --sandbox workspace-write directly modifies project files
        if (response.filesModified) {
          showMessage(shadow, '✅ Files modified successfully! Reload page to see changes.', 'success');
        } else {
          showMessage(shadow, '⚠️ Request completed (check console for details)', 'success');
        }
        
        // Show result preview in bubble
        showResultPreview(shadow, response.output);
      } else {
        showMessage(shadow, 'Request submitted successfully!', 'success');
        console.log('[LUMI Content] Response:', response);
      }

    } catch (error) {
      console.error('[LUMI Content] Submit error:', error);
      showMessage(shadow, `Failed: ${error.message}`, 'error');
    } finally {
      // Re-enable submit
      submitBtn.disabled = false;
      submitText.style.display = 'block';
      submitSpinner.style.display = 'none';
      updateSubmitButton(shadow);
    }
  }

  // Helper: get CSS selector for element
  function getElementSelector(element) {
    if (element.id) {
      return `#${element.id}`;
    }
    
    if (element.className) {
      const classes = element.className.split(' ').filter(c => c).join('.');
      if (classes) {
        return `${element.tagName.toLowerCase()}.${classes}`;
      }
    }

    // Build path
    let path = [];
    let current = element;
    while (current && current !== document.body) {
      let selector = current.tagName.toLowerCase();
      if (current.id) {
        selector += `#${current.id}`;
        path.unshift(selector);
        break;
      }
      path.unshift(selector);
      current = current.parentElement;
    }

    return path.join(' > ');
  }

  // Helper: get computed style summary
  function getComputedStyleSummary(element) {
    const computed = window.getComputedStyle(element);
    return {
      display: computed.display,
      position: computed.position,
      width: computed.width,
      height: computed.height,
      backgroundColor: computed.backgroundColor,
      color: computed.color,
      fontSize: computed.fontSize,
      fontFamily: computed.fontFamily,
      padding: computed.padding,
      margin: computed.margin,
      border: computed.border
    };
  }

  /**
   * Try to parse and apply CSS changes from Codex output
   * Returns number of changes applied
   */
  function tryApplyCSSChanges(output) {
    if (!output) return 0;

    let appliedCount = 0;

    // Extract CSS property changes from diff
    const changes = [];
    let match;

    // Pattern: - prop: old; \n + prop: new;
    const cssChangeRegex = /^-\s+([a-z-]+):\s*(.+?);?\s*$\n^\+\s+\1:\s*(.+?);?\s*$/gm;
    while ((match = cssChangeRegex.exec(output)) !== null) {
      changes.push({ property: match[1], value: match[3] });
    }

    // Fallback: look for added lines only
    if (changes.length === 0) {
      const addRegex = /^\+\s+([a-z-]+):\s*(.+?);?\s*$/gm;
      while ((match = addRegex.exec(output)) !== null) {
        changes.push({ property: match[1], value: match[2] });
      }
    }

    console.log('[LUMI] Extracted CSS changes:', changes);

    // Determine targets
    const targets = [];
    if (selectedElement) {
      targets.push(selectedElement);
    } else if (selectedBBox) {
      const centerX = Math.round((selectedBBox.left || 0) + (selectedBBox.width || 0) / 2);
      const centerY = Math.round((selectedBBox.top || 0) + (selectedBBox.height || 0) / 2);
      const stack = document.elementsFromPoint(centerX, centerY) || [];
      const preferred = stack.find(el => /^(H1|H2|H3|P|SPAN|DIV)$/i.test(el.tagName) && el.textContent.trim().length > 0);
      if (preferred) targets.push(preferred);
      if (stack[0]) targets.push(stack[0]);
    }
    // Broad fallback
    if (targets.length === 0) {
      document.querySelectorAll('h1, h2, h3, p').forEach(el => targets.push(el));
    }

    // Apply changes
    targets.forEach(el => {
      changes.forEach(change => {
        const camelProp = change.property.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
        try {
          el.style[camelProp] = change.value;
          appliedCount++;
          console.log(`[LUMI] Applied ${change.property}: ${change.value} to`, el);
        } catch (error) {
          console.warn('[LUMI] Failed to apply style:', change, error);
        }
      });
    });

    return appliedCount;
  }
  
  /**
   * Show result preview in bubble
   */
  function showResultPreview(shadow, output) {
    if (!output) return;
    
    // Extract the diff section
    const diffMatch = output.match(/```diff\n([\s\S]*?)\n```/);
    const explanation = output.match(/\[.*?\] codex\n\n(.*?)\n\n```diff/s);
    
    const container = shadow.querySelector('.lumi-container');
    if (!container) return;
    
    // Remove existing preview
    const existing = shadow.querySelector('.result-preview');
    if (existing) existing.remove();
    
    // Create preview element
    const preview = document.createElement('div');
    preview.className = 'result-preview';
    preview.style.cssText = `
      margin-top: 16px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      font-size: 13px;
      max-height: 300px;
      overflow-y: auto;
    `;
    
    if (explanation && explanation[1]) {
      const expDiv = document.createElement('div');
      expDiv.style.cssText = 'margin-bottom: 8px; opacity: 0.9;';
      expDiv.textContent = explanation[1].trim();
      preview.appendChild(expDiv);
    }
    
    if (diffMatch && diffMatch[1]) {
      const diffDiv = document.createElement('pre');
      diffDiv.style.cssText = `
        margin: 0;
        padding: 8px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
        font-size: 12px;
        overflow-x: auto;
        white-space: pre;
        font-family: 'SF Mono', Monaco, monospace;
      `;
      diffDiv.textContent = diffMatch[1];
      preview.appendChild(diffDiv);
    }
    
    container.appendChild(preview);
  }

  // Listen for messages from background
  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.type === 'TOGGLE_BUBBLE') {
      if (bubbleContainer && bubbleContainer.style.display !== 'none') {
        hideBubble();
      } else {
        showBubble();
      }
      sendResponse({ success: true });
    }
  });

  console.log('[LUMI Content] Initialized successfully');

})();

